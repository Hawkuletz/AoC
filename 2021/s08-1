#!/bin/bash
# 7digit displays!

uarr=()
sarr=()

segstxtarr=()
outtxtarr=()
digits=()

segsarr=() # experimental

# why is bash missing this? my approach is rather convoluted
gen_sort_arr_hlp()
{
	local crt=''
	for crt in "${uarr[@]}" ; do
		echo $crt
	done | sort -n |
	local i=0; while read -r crt ; do
		if (( i!=0 )) ; then
			echo -n ','
		fi
		(( i++ ))
		echo -n "$crt"
	done
	echo
}

gen_sort_arr()
{
	sarr=()
	local x=$(gen_sort_arr_hlp)
	IFS=, read -ra sarr <<<"$x"
}

# load $1 into uarr, char by char (I don't know how to process each char otherwise)
str2arr()
{
	local l=${#1}
	uarr=()
	for (( i=0 ; i<l ; i++ )) ; do
		uarr[$i]=${1:i:1}
	done
}


# process segment line
procsegln()
{
	local i=0
	local l=0
	while IFS=' ' read -r crt ; do
		l=${#crt}
		case $l in
			'2')
				digits[1]=$crt;;
			'3')
				digits[8]=$crt;;
			'4')
				digits[4]=$crt;;
			'7')
				digits[7]=$crt;;
			*)
				segsarr[i++]=$crt;;
		esac
	done <<<"$crtsegln"
	# search for 3 in segsarr
	for (( i=0 ; i<7 ; i++ )) ; do
		crt=${segsarr[$i]}
		one=${digits[1]}
		o0=${one:0:1}
		o1=${one:1:1}
		l=${#crt}
		if [[ l==$crt == *"$$o0"* && $crt == *"$o1"* ]] ; then
			digits[3]=$crt
			unset 'segsarr[$i]'
		fi
	done

		
}


i=0
while IFS= read -r ln; do
	lnarr[i++]=$ln
done

lcnt=${#lnarr[@]}

for (( i=0 ; i<lcnt ; i++ )) ; do
	crtsegln="${lnarr[i]%%|*}"
	crtsegln="${crtsegln% *}"
	procsegln
#	echo "seg[$i]=$crtsegln|"
done


