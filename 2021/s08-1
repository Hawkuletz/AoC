#!/bin/bash
# 7digit displays!

uarr=()
sarr=()

segstxtarr=()
outtxtarr=()
digits=()

segsarr=() # experimental

# why is bash missing this? my approach is rather convoluted
gen_sort_arr_hlp()
{
	local crt=''
	for crt in "${uarr[@]}" ; do
		echo $crt
	done | sort -n |
	local i=0; while read -r crt ; do
		if (( i!=0 )) ; then
			echo -n ','
		fi
		(( i++ ))
		echo -n "$crt"
	done
	echo
}

gen_sort_arr()
{
	sarr=()
	local x=$(gen_sort_arr_hlp)
	IFS=, read -ra sarr <<<"$x"
}

# load $1 into uarr, char by char (I don't know how to process each char otherwise)
str2arr()
{
	local l=${#1}
	uarr=()
	for (( i=0 ; i<l ; i++ )) ; do
		uarr[$i]=${1:i:1}
	done
}

chk39()
{
	declare -A a
	local x=''
	local sf=0
	for (( i=0 ; i<5 ; i++ )) ; do
		s=${d3:$i:1}
		a[$s]=1
	done
	declare -p a
	for (( i=0 ; i<6 ; i++ )) ; do
		x=${crt:$i:1}
		echo "a[$x] = ${a[$x]}"
		if [[ ${a[$x]} == 1 ]] ; then
			(( sf++ ))
		fi
	done
	return  $(( sf!=5 ))
}

# process segment line
procsegln()
{
	local i=0
	local l=0
	while IFS=' ' read -r crt ; do
		l=${#crt}
		case $l in
			'2')
				d1=$crt;;
			'3')
				d7=$crt;;
			'4')
				d4=$crt;;
			'7')
				d8=$crt;;
			*)
				segsarr[i++]=$crt;;
		esac
	done <<<"$crtsegln"

	# one's segments
	d10=${d1:0:1}
	d11=${d1:1:1}

	# search for 3 and 6 in segsarr (and remove from segsarr; but can't use unset, so just set them to '')
	i=0
	for crt in "${segsarr[@]}" ; do
		l=${#crt}
		if [[ $l == 5 && $crt == *"$d10"* && $crt == *"$d11"* ]] ; then
			d3=$crt
			segsarr[$i]=''
		fi

		# test has strange syntax, it's easier with 2 ifs
		# we are looking for a 6 segment digit that is missing one segment that is present in 1
		if [[ $l == 6 ]] ; then
			if ! [[ $crt == *"$d10"* && $crt == *"$d11"* ]] ; then
				d6=$crt
				# at this point we can identify top/bottom segments for 1
				if [[ $crt == *"$d10"* ]] ; then
					d1top=$d11
				else
					d1top=$d10
				fi
				segsarr[$i]=''
			fi
		fi
		(( i++ ))
	done

	# we now have 1,3,4,6,7,8 (2,5,9,0 are missing)
	# one more pass
	i=0
	for crt in "${segsarr[@]}" ; do
		l=${#crt}
		if [[ $l == 5 ]] ; then
			if [[ $crt == *"$d1top" ]] ; then
				d2 = $crt
			else
				d5 = $crt
			fi
			segsarr[$i]=''
		fi
		if [[ $l == 6 ]] ; then
			$
		(( i++ ))
	done

}


i=0
while IFS= read -r ln; do
	lnarr[i++]=$ln
done

lcnt=${#lnarr[@]}

for (( i=0 ; i<lcnt ; i++ )) ; do
	crtsegln="${lnarr[i]%%|*}"
	crtsegln="${crtsegln% *}"
	procsegln
#	echo "seg[$i]=$crtsegln|"
done


